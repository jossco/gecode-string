/*
gecode-string:	bounded-length string constraints for Gecode
url: 		github.com/jossco/gecode-string
author: 	Joseph D. Scott, Uppsala University
========
file: 		./src/open.hh
version: 	0.2.1
date: 		Wed Dec  3 17:58:46 CET 2014
========
This file originally based on code generated by the indexical compiler,
written by JN Monette @ Uppsala University.
*/
#include "gecode/driver.hh"
#include "gecode/int.hh"
#include "gecode/iter.hh" 
#include "gecode/int/rel.hh"
using namespace Gecode;

#ifndef OPEN_PROPS_HH
#define OPEN_PROPS_HH
namespace Gecode { namespace Open {
class OpenString {
	// This is all stuff that should be part of the variable class, prob.
public:
	static Iter::Ranges::Singleton PadRange;
	static int const padchar = -1;
	static Iter::Ranges::Singleton Symbols;
	// Print the value of <Array, Length> pair as bounded string
	static void print(std::ostream& os, IntVarArray X, IntVar Xn) ;
	static void printAsString(std::ostream& os, IntVarArray X, IntVar Xn);
	// Union of integer range and the padding character
	// (for initializing domains of "character" variables)
	static IntSet paddedIntSet(int n, int m) ;
};

class Invariant : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
public:
	Invariant(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn);
	Invariant(Home home, bool share, Invariant& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) Invariant(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,(X).size());
	}

};
}}

void open_invariant(Home home, IntVarArgs _X, IntVar _Xn);

namespace Gecode { namespace Open {
class CharacterAt : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	Int::IntView C;
	Int::IntView Index;
public:
	CharacterAt(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, Int::IntView _C, Int::IntView _Index);
	CharacterAt(Home home, bool share, CharacterAt& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, Int::IntView C, Int::IntView Index);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) CharacterAt(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,(X).size());
	}

};

}}

/*
 functions used to post the constraint.
 generated.
*/
void open_characterat(Home home, IntVarArgs _X, IntVar _Xn, IntVar _C, IntVar _Index);

namespace Gecode { namespace Open {
class Concat : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
	ViewArray<Int::IntView> Z;
	Int::IntView Zn;
	int Xmax;
	int Ymax;
	int Zmax;
public:
	Concat(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, ViewArray<Int::IntView> _Z, Int::IntView _Zn);
	Concat(Home home, bool share, Concat& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, ViewArray<Int::IntView> Z, Int::IntView Zn);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) Concat(home,share, *this);
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::quadratic(PropCost::LO,Yn.size()+(Y).size());
	}

};
}}

/*
 functions used to post the constraint generated.
*/
void open_concat(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVarArgs _Z, IntVar _Zn);

namespace Gecode { namespace Open {
class Equal : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
public:
	Equal(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn);
	Equal(Home home, bool share, Equal& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) Equal(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,Yn.size()+(Y).size());
	}
};

}}

/*
 functions used to post the constraint.
 generated.
*/
void open_equal(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn);

namespace Gecode { namespace Open {
class Substring : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
	Int::IntView Index;
public:
	Substring(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, Int::IntView _Index);
	Substring(Home home, bool share, Substring& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, Int::IntView Index);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) Substring(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::quadratic(PropCost::LO,Yn.size()+(Y).size());
	}

};
}}

/*
 functions used to post the constraint.
 generated.
*/
void open_substring(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Index);
#endif
