/*
This File has been generated by the indexical compiler,
written by JN Monette @ Uppsala University.
Please avoid modifying this file directly...
*/
#include "gecode/driver.hh"
#include "gecode/int.hh"
#include "gecode/iter.hh" 

using namespace Gecode;

 
#ifndef OPEN_char_avvvv_PROPAG_
#define OPEN_char_avvvv_PROPAG_
namespace OPEN_char_avvvv{
class OPEN_char_avvvv_genPropagator : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	Int::IntView C;
	Int::IntView Index;
public:
	OPEN_char_avvvv_genPropagator(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, Int::IntView _C, Int::IntView _Index);
	OPEN_char_avvvv_genPropagator(Home home, bool share, OPEN_char_avvvv_genPropagator& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, Int::IntView C, Int::IntView Index);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) OPEN_char_avvvv_genPropagator(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,(X).size());
	}

};

enum Propag {OPEN_char_avvvv_gen};
}//end of namespace OPEN_char_avvvv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_char(Home home, IntVarArgs _X, IntVar _Xn, IntVar _C, IntVar _Index, IntConLevel icl);
void OPEN_char(Home home, IntVarArgs _X, IntVar _Xn, IntVar _C, IntVar _Index, OPEN_char_avvvv::Propag _prop);
#endif //ifndef OPEN_char_avvvv_PROPAG_

 
#ifndef OPEN_concat_avvavvavv_PROPAG_
#define OPEN_concat_avvavvavv_PROPAG_
namespace OPEN_concat_avvavvavv{
class OPEN_concat_avvavvavv_genPropagator : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
	ViewArray<Int::IntView> Z;
	Int::IntView Zn;
public:
	OPEN_concat_avvavvavv_genPropagator(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, ViewArray<Int::IntView> _Z, Int::IntView _Zn);
	OPEN_concat_avvavvavv_genPropagator(Home home, bool share, OPEN_concat_avvavvavv_genPropagator& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, ViewArray<Int::IntView> Z, Int::IntView Zn);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) OPEN_concat_avvavvavv_genPropagator(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,Yn.size()+(Y).size());
	}

};

enum Propag {OPEN_concat_avvavvavv_gen};
}//end of namespace OPEN_concat_avvavvavv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_concat(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVarArgs _Z, IntVar _Zn, IntConLevel icl);
void OPEN_concat(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVarArgs _Z, IntVar _Zn, OPEN_concat_avvavvavv::Propag _prop);
#endif //ifndef OPEN_concat_avvavvavv_PROPAG_

 
#ifndef OPEN_equal_avvavv_PROPAG_
#define OPEN_equal_avvavv_PROPAG_
namespace OPEN_equal_avvavv{
class OPEN_equal_avvavv_genPropagator : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
public:
	OPEN_equal_avvavv_genPropagator(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn);
	OPEN_equal_avvavv_genPropagator(Home home, bool share, OPEN_equal_avvavv_genPropagator& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) OPEN_equal_avvavv_genPropagator(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,Yn.size()+(Y).size());
	}

};

enum Propag {OPEN_equal_avvavv_gen};
}//end of namespace OPEN_equal_avvavv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_equal(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntConLevel icl);
void OPEN_equal(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, OPEN_equal_avvavv::Propag _prop);
#endif //ifndef OPEN_equal_avvavv_PROPAG_

 
#ifndef OPEN_region_avvavvv_PROPAG_
#define OPEN_region_avvavvv_PROPAG_
namespace OPEN_region_avvavvv{
class OPEN_region_avvavvv_genPropagator : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
	Int::IntView Offset;
public:
	OPEN_region_avvavvv_genPropagator(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, Int::IntView _Offset);
	OPEN_region_avvavvv_genPropagator(Home home, bool share, OPEN_region_avvavvv_genPropagator& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, Int::IntView Offset);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) OPEN_region_avvavvv_genPropagator(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,Yn.size()+(Y).size());
	}

};

enum Propag {OPEN_region_avvavvv_gen};
}//end of namespace OPEN_region_avvavvv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_region(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Offset, IntConLevel icl);
void OPEN_region(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Offset, OPEN_region_avvavvv::Propag _prop);
#endif //ifndef OPEN_region_avvavvv_PROPAG_

 
#ifndef OPEN_substr_avvavvv_PROPAG_
#define OPEN_substr_avvavvv_PROPAG_
namespace OPEN_substr_avvavvv{
class OPEN_substr_avvavvv_genPropagator : public Propagator {
protected:
	ViewArray<Int::IntView> X;
	Int::IntView Xn;
	ViewArray<Int::IntView> Y;
	Int::IntView Yn;
	Int::IntView Index;
public:
	OPEN_substr_avvavvv_genPropagator(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, Int::IntView _Index);
	OPEN_substr_avvavvv_genPropagator(Home home, bool share, OPEN_substr_avvavvv_genPropagator& p);
	virtual size_t dispose(Space& home);
	static ExecStatus post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, Int::IntView Index);
	virtual ExecStatus propagate(Space& home, const Gecode::ModEventDelta& med);

	virtual Propagator* copy(Space& home, bool share){
		return new (home) OPEN_substr_avvavvv_genPropagator(home,share, *this);	
	}
	virtual PropCost cost(const Space& home, const ModEventDelta& med) const{
		return PropCost::linear(PropCost::LO,Yn.size()+(Y).size());
	}

};

enum Propag {OPEN_substr_avvavvv_gen};
}//end of namespace OPEN_substr_avvavvv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_substr(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Index, IntConLevel icl);
void OPEN_substr(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Index, OPEN_substr_avvavvv::Propag _prop);
#endif //ifndef OPEN_substr_avvavvv_PROPAG_ 
