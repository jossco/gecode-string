/*
This File has been generated by the indexical compiler,
written by JN Monette @ Uppsala University.
Please avoid modifying this file directly...
*/
#include "gecode/driver.hh"
#include "gecode/int.hh"
#include "gecode/iter.hh" 
#include "open.hh"

using namespace Gecode;

 

namespace Gecode { namespace Open { namespace CharacterAt {

CharacterAt::CharacterAt(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, Int::IntView _C, Int::IntView _Index)
: Propagator(home), X(_X),Xn(_Xn),C(_C),Index(_Index){
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	Index.subscribe(home,*this,Int::PC_INT_BND);
	Xn.subscribe(home,*this,Int::PC_INT_BND);
	C.subscribe(home,*this,Int::PC_INT_BND);
}
CharacterAt::CharacterAt(Home home, bool share, CharacterAt& p):Propagator(home, share, p){
	X.update(home,share,p.X);
	Xn.update(home,share,p.Xn);
	C.update(home,share,p.C);
	Index.update(home,share,p.Index);
}
size_t CharacterAt::dispose(Space& home){
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	Index.cancel(home,*this,Int::PC_INT_BND);
	Xn.cancel(home,*this,Int::PC_INT_BND);
	C.cancel(home,*this,Int::PC_INT_BND);
	(void) Propagator::dispose(home);
	return sizeof(*this);
}

ExecStatus CharacterAt::post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, Int::IntView C, Int::IntView Index){
	//initial prop
	bool nafp = false;

	GECODE_ME_CHECK_MODIFIED(nafp,Index.gq(home,0));
	GECODE_ME_CHECK_MODIFIED(nafp,Index.lq(home,(X.size() + -1)));

	(void) new (home) CharacterAt(home,X, Xn, C, Index);
	return ES_OK;
}
ExecStatus CharacterAt::propagate(Space& home, const Gecode::ModEventDelta& med){
	bool nafp = true;
	while(nafp){
		nafp = false;
		GECODE_ME_CHECK_MODIFIED(nafp,Index.lq(home,Xn.max()));
		int localvar3 = Index.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,localvar3));

		Region r(home);
		Iter::Ranges::Empty empty_naryvar0;

		Iter::Ranges::NaryUnion naryvar0(r,empty_naryvar0); 
		 for(int ii2=localvar3;ii2<=Index.max();ii2++){
		 	Iter::Ranges::Singleton localvar40(X[ii2].min(),X[ii2].max()); 
		 	naryvar0 |= localvar40;
		 } 
		GECODE_ME_CHECK_MODIFIED(nafp,C.inter_r(home,naryvar0));
		bool localvar4 = Index.assigned();
		if(localvar4){
			GECODE_ME_CHECK_MODIFIED(nafp,X[Index.val()].gq(home,C.min()));
		} 
		if(localvar4){
			GECODE_ME_CHECK_MODIFIED(nafp,X[Index.val()].lq(home,C.max()));
		} 
		 for(int ii0=0;ii0<=(X.size() + -1);ii0++){
		 	if(((C.max() < X[ii0].min()) || (X[ii0].max() < C.min()))){
		 		GECODE_ME_CHECK_MODIFIED(nafp,Index.nq(home,ii0));
		 	} 
		 } 
		bool localvar19 = false;
		if((C.assigned() && (localvar4 && X[Index.val()].assigned()))){
			localvar19 = ((Index.max() <= Xn.min()) && ((0 <= Index.min()) && (C.val() == X[Index.val()].val())));
		}else{
			localvar19 = false;
		}
		if(localvar19){
			return home.ES_SUBSUMED(*this);
		} 
	}
	if(X.assigned()&&Xn.assigned()&&C.assigned()&&Index.assigned())return home.ES_SUBSUMED(*this);
	return ES_FIX;
}


}}}//end of namespace OPEN_char_avvvv

/*
 functions used to post the constraint.
 generated.
*/
void characterat(Home home, IntVarArgs _X, IntVar _Xn, IntVar _C, IntVar _Index, IntConLevel icl=ICL_DEF){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	Int::IntView C(_C);
	Int::IntView Index(_Index);
	if(icl==ICL_BND) GECODE_ES_FAIL(Open::CharacterAt::CharacterAt::post(home,X, Xn, C, Index));
		else GECODE_ES_FAIL(Open::CharacterAt::CharacterAt::post(home,X, Xn, C, Index));

}
void characterat(Home home, IntVarArgs _X, IntVar _Xn, IntVar _C, IntVar _Index, Open::CharacterAt::Propag _prop){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	Int::IntView C(_C);
	Int::IntView Index(_Index);	
	if(_prop==Open::CharacterAt::OPEN_char_avvvv_gen) GECODE_ES_FAIL(Open::CharacterAt::CharacterAt::post(home,X, Xn, C, Index));
}


 

namespace Gecode { namespace Open { namespace Concat {

Concat::Concat(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, ViewArray<Int::IntView> _Z, Int::IntView _Zn)
: Propagator(home), X(_X),Xn(_Xn),Y(_Y),Yn(_Yn),Z(_Z),Zn(_Zn){
	Zn.subscribe(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=Z.size()-1;_i_++){
	 	Z[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	Xn.subscribe(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	Yn.subscribe(home,*this,Int::PC_INT_BND);
}
Concat::Concat(Home home, bool share, Concat& p):Propagator(home, share, p){
	X.update(home,share,p.X);
	Xn.update(home,share,p.Xn);
	Y.update(home,share,p.Y);
	Yn.update(home,share,p.Yn);
	Z.update(home,share,p.Z);
	Zn.update(home,share,p.Zn);
}
size_t Concat::dispose(Space& home){
	Zn.cancel(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=Z.size()-1;_i_++){
	 	Z[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	Xn.cancel(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	Yn.cancel(home,*this,Int::PC_INT_BND);
	(void) Propagator::dispose(home);
	return sizeof(*this);
}

ExecStatus Concat::post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, ViewArray<Int::IntView> Z, Int::IntView Zn){
	//initial prop
	(void) new (home) Concat(home,X, Xn, Y, Yn, Z, Zn);
	return ES_OK;
}
ExecStatus Concat::propagate(Space& home, const Gecode::ModEventDelta& med){
	bool nafp = true;
	while(nafp){
		nafp = false;
		int localvar41 = Xn.min();
		int localvar42 = Yn.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Zn.gq(home,(localvar41 + localvar42)));
		int localvar44 = Xn.max();
		int localvar45 = Yn.max();
		GECODE_ME_CHECK_MODIFIED(nafp,Zn.lq(home,(localvar44 + localvar45)));
		int localvar47 = Zn.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,(localvar47 + -localvar45)));
		int localvar51 = Zn.max();
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.lq(home,(localvar51 + -localvar42)));
		int localvar57 = -localvar44;
		GECODE_ME_CHECK_MODIFIED(nafp,Yn.gq(home,(localvar47 + localvar57)));
		int localvar61 = -localvar41;
		GECODE_ME_CHECK_MODIFIED(nafp,Yn.lq(home,(localvar51 + localvar61)));
		int localvar64 = (localvar47 + -1);
		int localvar66 = (localvar41 + -1);
		int localvar67 = std::min(localvar64,localvar66);
		if((0 <= localvar67)){
			 for(int i=0;i<=localvar67;i++){
			 	GECODE_ME_CHECK_MODIFIED(nafp,Z[i].gq(home,X[i].min()));
			 	GECODE_ME_CHECK_MODIFIED(nafp,Z[i].lq(home,X[i].max()));
			 	int localvar77 = X.size();
			 	if(((i < 0) || (0 < (-localvar77 + (i + 1))))){
			 		return ES_FAILED;
			 	} 
			 	 for(int ii15=0;ii15<=(localvar77 + -1);ii15++){
			 	 	if(((Z[i].max() < X[ii15].min()) || (X[ii15].max() < Z[i].min()))){
			 	 		if((0 == (-ii15 + i))){
			 	 			return ES_FAILED;
			 	 		} 
			 	 	} 
			 	 } 
			 } 
		} 
		int localvar99 = std::min(localvar66,localvar64);
		if((0 <= localvar99)){
			 for(int j=0;j<=localvar99;j++){
			 	int localvar106 = Z.size();
			 	int localvar107 = -j;
			 	if((((localvar106 + (localvar107 + -1)) < 0) || (0 < localvar107))){
			 		return ES_FAILED;
			 	} 
			 	 for(int ii9=0;ii9<=(localvar106 + -1);ii9++){
			 	 	if(((X[j].max() < Z[ii9].min()) || (Z[ii9].max() < X[j].min()))){
			 	 		if((0 == (ii9 + localvar107))){
			 	 			return ES_FAILED;
			 	 		} 
			 	 	} 
			 	 } 
			 	GECODE_ME_CHECK_MODIFIED(nafp,X[j].gq(home,Z[j].min()));
			 	GECODE_ME_CHECK_MODIFIED(nafp,X[j].lq(home,Z[j].max()));
			 } 
		} 
		int localvar129 = std::max(localvar44,0);
		int localvar134 = (localvar42 + -1);
		int localvar136 = std::min(localvar64,(localvar41 + localvar134));
		if((localvar129 <= localvar136)){
			int localvar264 = std::min(localvar57,0);
			int localvar272 = (localvar264 + localvar136);
			Iter::Ranges::NaryUnion naryvar1[localvar272+1];
			 for(int i=0;i<=localvar272;i++){
			 	Region r(home);
			 	Iter::Ranges::Empty empty_naryvar1_i_;

			 	naryvar1[i] = Iter::Ranges::NaryUnion(r,empty_naryvar1_i_); 
			 	 for(int ii22=(i + (localvar129 + localvar57));ii22<=(i + (localvar129 + localvar61));ii22++){
			 	 	Iter::Ranges::Singleton localvar388(Y[ii22].min(),Y[ii22].max()); 
			 	 	naryvar1[i] |= localvar388;
			 	 } 
			 } 
			 for(int i=localvar129;i<=localvar136;i++){
			 	GECODE_ME_CHECK_MODIFIED(nafp,Z[i].inter_r(home,naryvar1[(i + localvar264)]));
			 	int localvar151 = Y.size();
			 	GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,(-localvar151 + (i + 1))));
			 	GECODE_ME_CHECK_MODIFIED(nafp,Xn.lq(home,i));
			 	 for(int ii15=0;ii15<=(localvar151 + -1);ii15++){
			 	 	if(((Z[i].max() < Y[ii15].min()) || (Y[ii15].max() < Z[i].min()))){
			 	 		GECODE_ME_CHECK_MODIFIED(nafp,Xn.nq(home,(-ii15 + i)));
			 	 	} 
			 	 } 
			 } 
		} 
		int localvar168 = std::max(localvar61,0);
		int localvar176 = std::min(localvar134,(localvar57 + localvar64));
		if((localvar168 <= localvar176)){
			int localvar285 = std::min(localvar41,0);
			int localvar294 = (localvar285 + localvar176);
			Iter::Ranges::NaryUnion naryvar2[localvar294+1];
			 for(int j=0;j<=localvar294;j++){
			 	Region r(home);
			 	Iter::Ranges::Empty empty_naryvar2_j_;

			 	naryvar2[j] = Iter::Ranges::NaryUnion(r,empty_naryvar2_j_); 
			 	 for(int ii8=(j + (localvar168 + localvar41));ii8<=(j + (localvar168 + localvar44));ii8++){
			 	 	Iter::Ranges::Singleton localvar403(Z[ii8].min(),Z[ii8].max()); 
			 	 	naryvar2[j] |= localvar403;
			 	 } 
			 } 
			 for(int j=localvar168;j<=localvar176;j++){
			 	int localvar189 = -j;
			 	GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,localvar189));
			 	int localvar190 = Z.size();
			 	GECODE_ME_CHECK_MODIFIED(nafp,Xn.lq(home,(localvar190 + (localvar189 + -1))));
			 	 for(int ii9=0;ii9<=(localvar190 + -1);ii9++){
			 	 	if(((Y[j].max() < Z[ii9].min()) || (Z[ii9].max() < Y[j].min()))){
			 	 		GECODE_ME_CHECK_MODIFIED(nafp,Xn.nq(home,(ii9 + localvar189)));
			 	 	} 
			 	 } 
			 	GECODE_ME_CHECK_MODIFIED(nafp,Y[j].inter_r(home,naryvar2[(j + localvar285)]));
			 } 
		} 
		bool localvar208 = false;
		if(Zn.assigned()){
			bool naryvar3 = true;
			 for(int i=0;i<=std::min((Zn.max() + -1),(Xn.max() + -1));i++){
			 	bool localvar311 = false;
			 	if((X[i].assigned() && Z[i].assigned())){
			 		localvar311 = (X[i].val() == Z[i].val());
			 	}else{
			 		localvar311 = false;
			 	}
			 	naryvar3 = (naryvar3 && localvar311);
			 } 
			bool naryvar4 = true;
			 for(int j=0;j<=std::min((Xn.max() + -1),(Zn.max() + -1));j++){
			 	bool localvar317 = false;
			 	if((X[j].assigned() && Z[j].assigned())){
			 		localvar317 = (X[j].val() == Z[j].val());
			 	}else{
			 		localvar317 = false;
			 	}
			 	naryvar4 = (naryvar4 && localvar317);
			 } 
			bool naryvar5 = true;
			 for(int i=std::max(Xn.min(),0);i<=std::min((Zn.max() + -1),(Xn.max() + (Yn.max() + -1)));i++){
			 	bool localvar327 = false;
			 	if((Xn.assigned() && (Y[(i + -Xn.val())].assigned() && Z[i].assigned()))){
			 		localvar327 = (Y[(i + -Xn.val())].val() == Z[i].val());
			 	}else{
			 		localvar327 = false;
			 	}
			 	naryvar5 = (naryvar5 && localvar327);
			 } 
			bool naryvar6 = true;
			 for(int j=std::max(-Xn.max(),0);j<=std::min((Yn.max() + -1),(-Xn.min() + (Zn.max() + -1)));j++){
			 	bool localvar339 = false;
			 	if((Y[j].assigned() && (Xn.assigned() && Z[(j + Xn.val())].assigned()))){
			 		localvar339 = (Y[j].val() == Z[(j + Xn.val())].val());
			 	}else{
			 		localvar339 = false;
			 	}
			 	naryvar6 = (naryvar6 && localvar339);
			 } 
			localvar208 = (((Xn.max() + Yn.max()) <= Zn.val()) && ((Zn.val() <= (Xn.min() + Yn.min())) && (((std::min((Zn.max() + -1),(Xn.max() + -1)) < 0) || naryvar3) && (((std::min((Xn.max() + -1),(Zn.max() + -1)) < 0) || naryvar4) && (((std::min((Zn.max() + -1),(Xn.max() + (Yn.max() + -1))) < std::max(Xn.min(),0)) || naryvar5) && ((std::min((Yn.max() + -1),(-Xn.min() + (Zn.max() + -1))) < std::max(-Xn.max(),0)) || naryvar6))))));
		}else{
			localvar208 = false;
		}
		if(localvar208){
			return home.ES_SUBSUMED(*this);
		} 
	}
	if(X.assigned()&&Xn.assigned()&&Y.assigned()&&Yn.assigned()&&Z.assigned()&&Zn.assigned())return home.ES_SUBSUMED(*this);
	return ES_FIX;
}


}}}//end of namespace OPEN_concat_avvavvavv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_concat(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVarArgs _Z, IntVar _Zn, IntConLevel icl=ICL_DEF){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);
	ViewArray<Int::IntView> Z(home,_Z);
	Int::IntView Zn(_Zn);
	if(icl==ICL_BND) GECODE_ES_FAIL(Open::Concat::Concat::post(home,X, Xn, Y, Yn, Z, Zn));
		else GECODE_ES_FAIL(Open::Concat::Concat::post(home,X, Xn, Y, Yn, Z, Zn));

}
void OPEN_concat(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVarArgs _Z, IntVar _Zn, Open::Concat::Propag _prop){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);
	ViewArray<Int::IntView> Z(home,_Z);
	Int::IntView Zn(_Zn);	
	if(_prop==Open::Concat::OPEN_concat_avvavvavv_gen) GECODE_ES_FAIL(Open::Concat::Concat::post(home,X, Xn, Y, Yn, Z, Zn));
}


 

namespace Gecode { namespace Open { namespace Equal {

Equal::Equal(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn)
: Propagator(home), X(_X),Xn(_Xn),Y(_Y),Yn(_Yn){
	Xn.subscribe(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	Yn.subscribe(home,*this,Int::PC_INT_BND);
}
Equal::Equal(Home home, bool share, Equal& p):Propagator(home, share, p){
	X.update(home,share,p.X);
	Xn.update(home,share,p.Xn);
	Y.update(home,share,p.Y);
	Yn.update(home,share,p.Yn);
}
size_t Equal::dispose(Space& home){
	Xn.cancel(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	Yn.cancel(home,*this,Int::PC_INT_BND);
	(void) Propagator::dispose(home);
	return sizeof(*this);
}

ExecStatus Equal::post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn){
	//initial prop
	(void) new (home) Equal(home,X, Xn, Y, Yn);
	return ES_OK;
}
ExecStatus Equal::propagate(Space& home, const Gecode::ModEventDelta& med){
	bool nafp = true;
	while(nafp){
		nafp = false;
		int localvar404 = Yn.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,localvar404));
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.lq(home,Yn.max()));
		int localvar406 = Xn.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Yn.gq(home,localvar406));
		GECODE_ME_CHECK_MODIFIED(nafp,Yn.lq(home,Xn.max()));
		int localvar409 = (localvar406 + -1);
		int localvar411 = (localvar404 + -1);
		int localvar412 = std::min(localvar409,localvar411);
		if((0 <= localvar412)){
			 for(int i=0;i<=localvar412;i++){
			 	GECODE_ME_CHECK_MODIFIED(nafp,X[i].gq(home,Y[i].min()));
			 	GECODE_ME_CHECK_MODIFIED(nafp,X[i].lq(home,Y[i].max()));
			 	int localvar422 = Y.size();
			 	if(((i < 0) || (0 < (-localvar422 + (i + 1))))){
			 		return ES_FAILED;
			 	} 
			 	 for(int ii15=0;ii15<=(localvar422 + -1);ii15++){
			 	 	if(((X[i].max() < Y[ii15].min()) || (Y[ii15].max() < X[i].min()))){
			 	 		if((0 == (-ii15 + i))){
			 	 			return ES_FAILED;
			 	 		} 
			 	 	} 
			 	 } 
			 } 
		} 
		int localvar444 = std::min(localvar411,localvar409);
		if((0 <= localvar444)){
			 for(int j=0;j<=localvar444;j++){
			 	int localvar451 = X.size();
			 	int localvar452 = -j;
			 	if((((localvar451 + (localvar452 + -1)) < 0) || (0 < localvar452))){
			 		return ES_FAILED;
			 	} 
			 	 for(int ii9=0;ii9<=(localvar451 + -1);ii9++){
			 	 	if(((Y[j].max() < X[ii9].min()) || (X[ii9].max() < Y[j].min()))){
			 	 		if((0 == (ii9 + localvar452))){
			 	 			return ES_FAILED;
			 	 		} 
			 	 	} 
			 	 } 
			 	GECODE_ME_CHECK_MODIFIED(nafp,Y[j].gq(home,X[j].min()));
			 	GECODE_ME_CHECK_MODIFIED(nafp,Y[j].lq(home,X[j].max()));
			 } 
		} 
		bool localvar473 = false;
		if((Xn.assigned() && Yn.assigned())){
			bool naryvar7 = true;
			 for(int i=0;i<=std::min((Xn.max() + -1),(Yn.max() + -1));i++){
			 	bool localvar500 = false;
			 	if((X[i].assigned() && Y[i].assigned())){
			 		localvar500 = (X[i].val() == Y[i].val());
			 	}else{
			 		localvar500 = false;
			 	}
			 	naryvar7 = (naryvar7 && localvar500);
			 } 
			bool naryvar8 = true;
			 for(int j=0;j<=std::min((Yn.max() + -1),(Xn.max() + -1));j++){
			 	bool localvar506 = false;
			 	if((X[j].assigned() && Y[j].assigned())){
			 		localvar506 = (X[j].val() == Y[j].val());
			 	}else{
			 		localvar506 = false;
			 	}
			 	naryvar8 = (naryvar8 && localvar506);
			 } 
			localvar473 = ((Xn.val() == Yn.val()) && (((std::min((Xn.max() + -1),(Yn.max() + -1)) < 0) || naryvar7) && ((std::min((Yn.max() + -1),(Xn.max() + -1)) < 0) || naryvar8)));
		}else{
			localvar473 = false;
		}
		if(localvar473){
			return home.ES_SUBSUMED(*this);
		} 
	}
	if(X.assigned()&&Xn.assigned()&&Y.assigned()&&Yn.assigned())return home.ES_SUBSUMED(*this);
	return ES_FIX;
}


}}}//end of namespace OPEN_equal_avvavv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_equal(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntConLevel icl=ICL_DEF){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);
	if(icl==ICL_BND) GECODE_ES_FAIL(Open::Equal::Equal::post(home,X, Xn, Y, Yn));
		else GECODE_ES_FAIL(Open::Equal::Equal::post(home,X, Xn, Y, Yn));

}
void OPEN_equal(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, Open::Equal::Propag _prop){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);	
	if(_prop==Open::Equal::OPEN_equal_avvavv_gen) GECODE_ES_FAIL(Open::Equal::Equal::post(home,X, Xn, Y, Yn));
}


namespace Gecode { namespace Open { namespace Substring {

Substring::Substring(Home home, ViewArray<Int::IntView> _X, Int::IntView _Xn, ViewArray<Int::IntView> _Y, Int::IntView _Yn, Int::IntView _Index)
: Propagator(home), X(_X),Xn(_Xn),Y(_Y),Yn(_Yn),Index(_Index){
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
	Index.subscribe(home,*this,Int::PC_INT_BND);
	Yn.subscribe(home,*this,Int::PC_INT_BND);
	Xn.subscribe(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].subscribe(home,*this,Int::PC_INT_BND);
	 } 
}
Substring::Substring(Home home, bool share, Substring& p):Propagator(home, share, p){
	X.update(home,share,p.X);
	Xn.update(home,share,p.Xn);
	Y.update(home,share,p.Y);
	Yn.update(home,share,p.Yn);
	Index.update(home,share,p.Index);
}
size_t Substring::dispose(Space& home){
	 for(int _i_=0;_i_<=X.size()-1;_i_++){
	 	X[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	Index.cancel(home,*this,Int::PC_INT_BND);
	Yn.cancel(home,*this,Int::PC_INT_BND);
	Xn.cancel(home,*this,Int::PC_INT_BND);
	 for(int _i_=0;_i_<=Y.size()-1;_i_++){
	 	Y[_i_].cancel(home,*this,Int::PC_INT_BND);
	 } 
	(void) Propagator::dispose(home);
	return sizeof(*this);
}

ExecStatus Substring::post(Space& home, ViewArray<Int::IntView> X, Int::IntView Xn, ViewArray<Int::IntView> Y, Int::IntView Yn, Int::IntView Index){
	//initial prop
	(void) new (home) Substring(home,X, Xn, Y, Yn, Index);
	return ES_OK;
}
ExecStatus Substring::propagate(Space& home, const Gecode::ModEventDelta& med){
	bool nafp = true;
	while(nafp){
		nafp = false;
		int localvar742 = Xn.max();
		int localvar743 = Index.min();
		int localvar744 = -localvar743;
		GECODE_ME_CHECK_MODIFIED(nafp,Yn.lq(home,(localvar742 + localvar744)));
		int localvar747 = Yn.min();
		GECODE_ME_CHECK_MODIFIED(nafp,Index.lq(home,(localvar742 + -localvar747)));
		GECODE_ME_CHECK_MODIFIED(nafp,Xn.gq(home,(localvar747 + localvar743)));
		int localvar753 = Index.max();
		int localvar754 = std::max(localvar753,0);
		int localvar755 = Xn.min();
		int localvar756 = (localvar755 + -1);
		int localvar759 = (localvar747 + -1);
		int localvar761 = std::min(localvar756,(localvar743 + localvar759));
		if((localvar754 <= localvar761)){
			int localvar865 = -localvar753;
			int localvar866 = std::min(localvar865,0);
			int localvar874 = (localvar866 + localvar761);
			Iter::Ranges::NaryUnion naryvar13[localvar874+1];
			 for(int i=0;i<=localvar874;i++){
			 	Region r(home);
			 	Iter::Ranges::Empty empty_naryvar13_i_;

			 	naryvar13[i] = Iter::Ranges::NaryUnion(r,empty_naryvar13_i_); 
			 	 for(int ii22=(i + (localvar754 + localvar865));ii22<=(i + (localvar754 + localvar744));ii22++){
			 	 	Iter::Ranges::Singleton localvar968(Y[ii22].min(),Y[ii22].max()); 
			 	 	naryvar13[i] |= localvar968;
			 	 } 
			 } 
			 for(int i=localvar754;i<=localvar761;i++){
			 	GECODE_ME_CHECK_MODIFIED(nafp,X[i].inter_r(home,naryvar13[(i + localvar866)]));
			 	int localvar776 = Y.size();
			 	GECODE_ME_CHECK_MODIFIED(nafp,Index.gq(home,(-localvar776 + (i + 1))));
			 	GECODE_ME_CHECK_MODIFIED(nafp,Index.lq(home,i));
			 	 for(int ii15=0;ii15<=(localvar776 + -1);ii15++){
			 	 	if(((X[i].max() < Y[ii15].min()) || (Y[ii15].max() < X[i].min()))){
			 	 		GECODE_ME_CHECK_MODIFIED(nafp,Index.nq(home,(-ii15 + i)));
			 	 	} 
			 	 } 
			 } 
		} 
		int localvar793 = std::max(localvar744,0);
		int localvar797 = -localvar753;
		int localvar801 = std::min(localvar759,(localvar797 + localvar756));
		if((localvar793 <= localvar801)){
			int localvar887 = std::min(localvar743,0);
			int localvar896 = (localvar887 + localvar801);
			Iter::Ranges::NaryUnion naryvar14[localvar896+1];
			 for(int j=0;j<=localvar896;j++){
			 	Region r(home);
			 	Iter::Ranges::Empty empty_naryvar14_j_;

			 	naryvar14[j] = Iter::Ranges::NaryUnion(r,empty_naryvar14_j_); 
			 	 for(int ii8=(j + (localvar793 + localvar743));ii8<=(j + (localvar793 + localvar753));ii8++){
			 	 	Iter::Ranges::Singleton localvar983(X[ii8].min(),X[ii8].max()); 
			 	 	naryvar14[j] |= localvar983;
			 	 } 
			 } 
			 for(int j=localvar793;j<=localvar801;j++){
			 	int localvar814 = -j;
			 	GECODE_ME_CHECK_MODIFIED(nafp,Index.gq(home,localvar814));
			 	int localvar815 = X.size();
			 	GECODE_ME_CHECK_MODIFIED(nafp,Index.lq(home,(localvar815 + (localvar814 + -1))));
			 	 for(int ii9=0;ii9<=(localvar815 + -1);ii9++){
			 	 	if(((Y[j].max() < X[ii9].min()) || (X[ii9].max() < Y[j].min()))){
			 	 		GECODE_ME_CHECK_MODIFIED(nafp,Index.nq(home,(ii9 + localvar814)));
			 	 	} 
			 	 } 
			 	GECODE_ME_CHECK_MODIFIED(nafp,Y[j].inter_r(home,naryvar14[(j + localvar887)]));
			 } 
		} 
		bool naryvar15 = true;
		int localvar909 = std::max(localvar743,0);
		int localvar911 = (localvar742 + -1);
		int localvar913 = Yn.max();
		int localvar914 = (localvar913 + -1);
		int localvar916 = std::min(localvar911,(localvar753 + localvar914));
		 for(int i=localvar909;i<=localvar916;i++){
		 	bool localvar917 = false;
		 	if((X[i].assigned() && (Index.assigned() && Y[(i + -Index.val())].assigned()))){
		 		localvar917 = (X[i].val() == Y[(i + -Index.val())].val());
		 	}else{
		 		localvar917 = false;
		 	}
		 	naryvar15 = (naryvar15 && localvar917);
		 } 
		bool naryvar16 = true;
		int localvar920 = std::max(localvar797,0);
		int localvar928 = std::min(localvar914,(localvar744 + localvar911));
		 for(int j=localvar920;j<=localvar928;j++){
		 	bool localvar929 = false;
		 	if((Index.assigned() && (X[(j + Index.val())].assigned() && Y[j].assigned()))){
		 		localvar929 = (X[(j + Index.val())].val() == Y[j].val());
		 	}else{
		 		localvar929 = false;
		 	}
		 	naryvar16 = (naryvar16 && localvar929);
		 } 
		if((((localvar913 + localvar753) <= localvar755) && (((localvar916 < localvar909) || naryvar15) && ((localvar928 < localvar920) || naryvar16)))){
			return home.ES_SUBSUMED(*this);
		} 
	}
	if(X.assigned()&&Xn.assigned()&&Y.assigned()&&Yn.assigned()&&Index.assigned())return home.ES_SUBSUMED(*this);
	return ES_FIX;
}


}}}//end of namespace OPEN_substr_avvavvv

/*
 functions used to post the constraint.
 generated.
*/
void OPEN_substr(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Index, IntConLevel icl=ICL_DEF){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);
	Int::IntView Index(_Index);
	if(icl==ICL_BND) GECODE_ES_FAIL(Open::Substring::Substring::post(home,X, Xn, Y, Yn, Index));
		else GECODE_ES_FAIL(Open::Substring::Substring::post(home,X, Xn, Y, Yn, Index));

}
void OPEN_substr(Home home, IntVarArgs _X, IntVar _Xn, IntVarArgs _Y, IntVar _Yn, IntVar _Index, Open::Substring::Propag _prop){
	if(home.failed())return;
	ViewArray<Int::IntView> X(home,_X);
	Int::IntView Xn(_Xn);
	ViewArray<Int::IntView> Y(home,_Y);
	Int::IntView Yn(_Yn);
	Int::IntView Index(_Index);	
	if(_prop==Open::Substring::OPEN_substr_avvavvv_gen) GECODE_ES_FAIL(Open::Substring::Substring::post(home,X, Xn, Y, Yn, Index));
}
 
