/*
This File has been generated by the indexical compiler,
written by JN Monette @ Uppsala University.
Please avoid modifying this file directly...
*/
#include "gecode/flatzinc.hh"
#include "flatzinc-support.hh"
#include "open.hh"
#include "open-layered-graph.hh"
namespace Gecode { namespace FlatZinc {

void p_str_concat(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
	IntVarArgs X  = s.arg2intvarargs(ce[0]);
	IntVar Xn  = s.arg2IntVar(ce[1]);
	IntVarArgs Y  = s.arg2intvarargs(ce[2]);
	IntVar Yn  = s.arg2IntVar(ce[3]);
	IntVarArgs Z  = s.arg2intvarargs(ce[4]);
	IntVar Zn  = s.arg2IntVar(ce[5]);
	open_concat(s, X, Xn, Y, Yn, Z, Zn);
}

void p_str_equal(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
	IntVarArgs X  = s.arg2intvarargs(ce[0]);
	IntVar Xn  = s.arg2IntVar(ce[1]);
	IntVarArgs Y  = s.arg2intvarargs(ce[2]);
	IntVar Yn  = s.arg2IntVar(ce[3]);
	open_equal(s, X, Xn, Y, Yn);
}

void p_str_pad(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
	IntVarArgs X  = s.arg2intvarargs(ce[0]);
	IntVar Xn  = s.arg2IntVar(ce[1]);
	open_invariant(s, X, Xn);
}

void p_str_char(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
	IntVarArgs X  = s.arg2intvarargs(ce[0]);
	IntVar Xn  = s.arg2IntVar(ce[1]);
	IntVar C  = s.arg2IntVar(ce[2]);
	IntVar Index  = s.arg2IntVar(ce[3]);
	open_characterat(s, X, Xn, C, Index);
}

void p_str_substr(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
	IntVarArgs X  = s.arg2intvarargs(ce[0]);
	IntVar Xn  = s.arg2IntVar(ce[1]);
	IntVarArgs Y  = s.arg2intvarargs(ce[2]);
	IntVar Yn  = s.arg2IntVar(ce[3]);
	IntVar Index  = s.arg2IntVar(ce[4]);
	open_substring(s, X, Xn, Y, Yn, Index);
}

void p_str_regular(FlatZincSpace& s, const ConExpr& ce, AST::Node* ann) {
  IntVarArgs iv = s.arg2intvarargs(ce[0]);
	IntVar length = s.arg2IntVar(ce[1]);
  int q = ce[2]->getInt();
  int symbols = ce[3]->getInt();
  IntArgs d = s.arg2intargs(ce[4]);
  int q0 = ce[5]->getInt();

  int noOfTrans = 0;
  for (int i=1; i<=q; i++) {
    for (int j=1; j<=symbols; j++) {
      if (d[(i-1)*symbols+(j-1)] > 0)
        noOfTrans++;
    }
  }

  Region re(s);
  DFA::Transition* t = re.alloc<DFA::Transition>(noOfTrans+1);
  noOfTrans = 0;
  for (int i=1; i<=q; i++) {
    for (int j=1; j<=symbols; j++) {
      if (d[(i-1)*symbols+(j-1)] > 0) {
        t[noOfTrans].i_state = i;
        t[noOfTrans].symbol  = j;
        t[noOfTrans].o_state = d[(i-1)*symbols+(j-1)];
        noOfTrans++;
      }
    }
  }
  t[noOfTrans].i_state = -1;

  // Final states
  AST::SetLit* sl = ce[6]->getSet();
  int* f;
  if (sl->interval) {
    f = static_cast<int*>(malloc(sizeof(int)*(sl->max-sl->min+2)));
    for (int i=sl->min; i<=sl->max; i++)
      f[i-sl->min] = i;
    f[sl->max-sl->min+1] = -1;
  } else {
    f = static_cast<int*>(malloc(sizeof(int)*(sl->s.size()+1)));
    for (int j=sl->s.size(); j--; )
      f[j] = sl->s[j];
    f[sl->s.size()] = -1;
  }
    
  DFA dfa(q0,t,f);
  free(f);
	extensional(s, iv, dfa, length);
  //extensional(s, iv, dfa, s.ann2icl(ann));
}

class MyPoster261 {
   public:
   MyPoster261(void) {
   registry().add("str_concat", &p_str_concat);
   registry().add("str_equal", &p_str_equal);
   registry().add("str_characterat", &p_str_char);
   registry().add("str_substring", &p_str_substr);
   registry().add("str_regular", &p_str_regular);
	 registry().add("str_pad", &p_str_pad);
   }
};

MyPoster261 my_poster261;
}}
